<?php

declare(strict_types=1);


namespace Codewithkyrian\Transformers\Generation\Streamers;

use InvalidArgumentException;
use Symfony\Component\Console\Output\ConsoleOutput;
use Symfony\Component\Console\Output\ConsoleSectionOutput;
use Symfony\Component\Console\Output\OutputInterface;

/**
 * Utility class to handle streaming of tokens generated by whisper speech-to-text models.
 *
 * Callback functions are invoked when each of the following events occur:
 *   - A new chunk starts (onChunkStart)
 *   - A new token is generated (onStream)
 *   - A chunk ends (onChunkEnd)
 *   - The stream is finalized (onStreamEnd)
 */
class WhisperTextStreamer extends Streamer
{
    protected mixed $onTimestampStartCallback = null;
    protected mixed $onTimestampEndCallback = null;
    protected int $timestampBegin;
    protected float $timePrecision = 0.02;
    protected bool $waitingForTimestamp = false;
    protected float $cumulativeOffset = 0.0;

    protected array $chunksToProcess = [[
        'tokens' => [],
        'finalized' => false,
    ]];

    public static function make(): static
    {
        $streamer = parent::make();

        $streamer->onStreamCallback ??= function ($value) {};

        $streamer->onStreamEndCallback ??= function () {};

        return $streamer;
    }

    public function put(mixed $value): void
    {
        if (count($value) > 1) {
            throw new InvalidArgumentException("WhisperTextStreamer only supports batch size 1");
        }

        $tokens = $value[0]['output_token_ids'];

        if (empty($tokens)) return;

        // Check if the token is a timestamp
        $offset = end($tokens) - $this->timestampBegin;

        if ($offset >= 0) {
            $time = $offset * $this->timePrecision;
            if ($this->waitingForTimestamp) {
                if ($this->onTimestampEndCallback !== null) {
                    call_user_func($this->onTimestampEndCallback, $time);
                }
            } else {
                if ($this->onTimestampStartCallback !== null) {
                    call_user_func($this->onTimestampStartCallback, $time);
                }
            }
            $this->waitingForTimestamp = !$this->waitingForTimestamp;
            $value[0]['output_token_ids'] = [];
        }

        $lastChunk = &$this->chunksToProcess[count($this->chunksToProcess) - 1];
        $lastChunk['tokens'] = [...$value[0]['output_token_ids']];

        [$decodedText, $optional] = $this->tokenizer->decodeASR($this->chunksToProcess, $this->timePrecision);

        if ($this->onStreamCallback !== null) {
            call_user_func(
                $this->onStreamCallback,
                $decodedText
            );
        }
    }

    public function putChunk(array $chunk): void
    {
        $lastChunk = &$this->chunksToProcess[count($this->chunksToProcess) - 1];

        // Overwrite last chunk with new info
        $lastChunk = $chunk;
        $lastChunk['finalized'] = true;

        $this->cumulativeOffset += $chunk['stride'][0];

        // Create an empty chunk after, if it not the last chunk
        if (!$chunk['is_last']) {
            $this->chunksToProcess[] = [
                'tokens' => [],
                'finalized' => false
            ];
        }
    }

    public function onTimestampStart(callable $callback): static
    {
        $this->onTimestampStartCallback = $callback;
        return $this;
    }

    public function onTimestampEnd(callable $callback): static
    {
        $this->onTimestampEndCallback = $callback;
        return $this;
    }

    public function setTimestampBegin(int $timestampBegin): static
    {
        $this->timestampBegin = $timestampBegin;
        return $this;
    }

    public function setTimePrecision(float $timePrecision): static
    {
        $this->timePrecision = $timePrecision;
        return $this;
    }


    public function end(): void
    {
        if ($this->onStreamEndCallback !== null) {
            call_user_func($this->onStreamEndCallback);
        }
    }
}
